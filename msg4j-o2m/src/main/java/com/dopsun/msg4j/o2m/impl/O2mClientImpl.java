/*
 * Copyright (c) 2017 Dop Sun. All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.dopsun.msg4j.o2m.impl;

import java.time.Duration;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedTransferQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.TransferQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.StampedLock;
import java.util.function.Function;

import javax.annotation.Nullable;
import javax.annotation.concurrent.ThreadSafe;

import com.dopsun.msg4j.core.delivery.transports.ConsumerMode;
import com.dopsun.msg4j.core.delivery.transports.ProducerMode;
import com.dopsun.msg4j.core.delivery.transports.Transport;
import com.dopsun.msg4j.core.delivery.transports.TransportException;
import com.dopsun.msg4j.core.delivery.transports.TransportSubscriberSettings;
import com.dopsun.msg4j.core.delivery.transports.TransportSubscription;
import com.dopsun.msg4j.core.delivery.transports.TransportTopic;
import com.dopsun.msg4j.core.messages.ImmutableMessage;
import com.dopsun.msg4j.core.messages.Message;
import com.dopsun.msg4j.o2m.O2mClient;
import com.dopsun.msg4j.o2m.O2mClientConfiguration;
import com.dopsun.msg4j.o2m.O2mClientEventListener;
import com.dopsun.msg4j.o2m.O2mClientState;
import com.dopsun.msg4j.o2m.O2mClientSubscription;
import com.dopsun.msg4j.o2m.O2mClientSubscriptionCallback;
import com.dopsun.msg4j.o2m.O2mClientSubscriptionFilter;
import com.dopsun.msg4j.o2m.O2mClientSubscriptionMode;
import com.dopsun.msg4j.o2m.O2mServiceException;
import com.dopsun.msg4j.o2m.impl.O2mMessages.Messages.ChannelSnapshotReader;
import com.google.common.collect.ImmutableMap;
import com.google.common.util.concurrent.AbstractExecutionThreadService;
import com.google.common.util.concurrent.Service;

/**
 * @author Dop Sun
 * @since 1.0.0
 */
@ThreadSafe
final class O2mClientImpl implements O2mClient, ClientMessageHandlerContext {
    /**
     * Transport used by this client.
     */
    private final Transport transport;

    /**
     * Auto generated by {@link O2mClientConfiguration#getSessionIdSupplier()} on start up.
     */
    private final String sessionId;

    /**
     * Producer based on {@link O2mClientConfiguration#getPublishSubjectProducer()}
     */
    private final Function<String, String> publishSubjectProducer;

    /**
     * Topic generated based on {@link #publishSubjectProducer}.
     */
    private final ConcurrentHashMap<String, TransportTopic> publishTopics = new ConcurrentHashMap<>();

    private final TransportTopic requestTopic;

    /**
     * This is started during {@link O2mClientState#INITIALIZING}.
     */
    private final TransportSubscription sessionSubscription;

    /**
     * This subscription is established before connecting. This is by design, as server state may
     * impacting the connect process, e.g. if server publishes stopped message, then client should
     * stop trying.
     * 
     * <p>
     * This is started during {@link O2mClientState#INITIALIZING}.
     * </p>
     */
    private final TransportSubscription systemSubscription;

    /** Server session id, received by the connecting reply message */
    private final AtomicReference<String> serverSessionId = new AtomicReference<>();
    private final AtomicReference<Duration> serverHeartbeatInterval = new AtomicReference<>();

    private final ChannelRequestPublisher<CompletableFuture<Message>> requestPublisher;

    /**
     * Requests pending for server to complete, by setting future result. Key is
     * <code>requestSeqNum</code>, the message set for the future is whole reply envelop.
     */
    private final ConcurrentHashMap<Long, CompletableFuture<Message>> pendingRequests = new ConcurrentHashMap<>();

    /**
     * State of this client.
     */
    private final AtomicReference<O2mClientState> state = new AtomicReference<>(
            O2mClientState.INITIALIZING);

    /**
     * A StampedLock for {@link #state}
     */
    private final StampedLock stateRWLock = new StampedLock();

    /**
     * Events manager.
     */
    private final O2mClientEvents o2mClientEvents = new O2mClientEvents(this);

    /**
     * All subscriptions for this client.
     */
    private final ConcurrentHashMap<String, O2mSubscriptionImpl> allSubscriptionById = new ConcurrentHashMap<>();

    /**
     * All live subscriptions, {@link O2mClientSubscriptionMode#UPDATE} or
     * {@link O2mClientSubscriptionMode#REALTIME}, by channel code. Only one live subscription for a
     * channel code allowed.
     */
    private final ConcurrentHashMap<String, O2mSubscriptionImpl> liveSubscriptionByChannelCode = new ConcurrentHashMap<>();

    /**
     * Store next subscription id for a order.
     * 
     * @see #generateSubscriptionIdForChannelCode(String)
     */
    private final ConcurrentHashMap<String, AtomicLong> nextSubscriptionIdForChannelCode = new ConcurrentHashMap<>();

    /**
     * System request handlers.
     */
    private final Map<String, ClientMessageHandler> clientMessageHandlers;

    O2mClientImpl(Transport transport, O2mClientConfiguration config)
            throws TransportException, O2mServiceException, InterruptedException {
        Objects.requireNonNull(transport);
        Objects.requireNonNull(config);
        Objects.requireNonNull(config.getClientId());
        Objects.requireNonNull(config.getServerId());
        Objects.requireNonNull(config.getVersion());
        Objects.requireNonNull(config.getSessionIdSupplier());

        Objects.requireNonNull(config.getSystemSubject());
        Objects.requireNonNull(config.getRequestSubject());
        Objects.requireNonNull(config.getPublishSubjectProducer());
        Objects.requireNonNull(config.getSessionSubjectProducer());

        this.transport = transport;
        this.sessionId = config.getSessionIdSupplier().get();
        this.publishSubjectProducer = config.getPublishSubjectProducer();

        this.requestTopic = transport.createTopic(config.getRequestSubject(),
                ProducerMode.NON_PERSISTENT, ConsumerMode.NO_ACK);

        String sessionSubject = config.getSessionSubjectProducer().apply(sessionId);
        TransportTopic sessionTopic = transport.createTopic(sessionSubject,
                ProducerMode.NON_PERSISTENT, ConsumerMode.NO_ACK);
        TransportSubscriberSettings settinsg = TransportSubscriberSettings.create();
        this.sessionSubscription = transport.subscribe(sessionTopic, settinsg,
                this::onSessionMessage);

        TransportTopic systemTopic = transport.createTopic(config.getSystemSubject(),
                ProducerMode.NON_PERSISTENT, ConsumerMode.NO_ACK);
        TransportSubscriberSettings systemSettings = TransportSubscriberSettings.create();
        this.systemSubscription = transport.subscribe(systemTopic, systemSettings,
                this::onSystemMessage);

        this.requestPublisher = new ChannelRequestPublisher<>(sessionId,
                () -> serverSessionId.get(), (m) -> {
                    long seqNum = O2mMessages.Fields.SeqNum.get(m);

                    CompletableFuture<Message> future = new CompletableFuture<>();
                    pendingRequests.put(Long.valueOf(seqNum), future);

                    try {
                        transport.publish(requestTopic, m);
                    } catch (TransportException e) {
                        throw new O2mServiceException(e);
                    }

                    return future;
                });

        /** @formatter:off */
        ImmutableMap.Builder<String, ClientMessageHandler> builder = ImmutableMap.builder();

        builder.put(O2mMessages.Messages.SERVER_CLIENT_HEARTBEAT, new ClientSystemServerClientHeartbeatMessageHandler(this));
        builder.put(O2mMessages.Messages.SERVER_STARTED_NOTIFICATION, new ClientSystemServerStartedMessageHandler(this));
        builder.put(O2mMessages.Messages.SERVER_STOPPED_NOTIFICATION, new ClientSystemServerStoppedMessageHandler(this));

        builder.put(O2mMessages.Messages.USER_REPLY, new ClientSessionUserReplyMessageHandler(this));
        builder.put(O2mMessages.Messages.SUBSCRIBE_REPLY, new ClientSessionSubscribeReplyMessageHandler(this));
        builder.put(O2mMessages.Messages.CHANNEL_SNAPSHOT, new ClientSessionChannelSnapshotMessageHandler(this));
        builder.put(O2mMessages.Messages.CLIENT_CONNECT_REPLY, new ClientSessionClientConnectReplyMessageHandler(this));
        builder.put(O2mMessages.Messages.CLIENT_SESSION_REPLACED_REPLY, new ClientSessionReplacedMessageHandler(this));
        
        builder.put(O2mMessages.Messages.CHANNEL_UPDATE, new ClientPublishChannelUpdateMessageHandler(this));
        
        clientMessageHandlers = builder.build();
        /** @formatter:on */

        comareAndSetState(O2mClientState.INITIALIZING, O2mClientState.CONNECTING);

        boolean connected = tryConnecting(config);

        if (connected) {
            comareAndSetState(O2mClientState.CONNECTING, O2mClientState.ACTIVE);
        } else {
            comareAndSetState(O2mClientState.CONNECTING, O2mClientState.FAILED);
        }
    }

    @Override
    public void close() throws Exception {
        this.close(false);
    }

    @Override
    public void close(boolean failed) throws Exception {
        comareAndSetState(O2mClientState.ACTIVE, O2mClientState.DISCONNECTING);

        requestPublisher.publishClientDisconnect();

        comareAndSetState(O2mClientState.DISCONNECTING, O2mClientState.FINALIZING);

        systemSubscription.close();
        sessionSubscription.close();

        if (failed) {
            comareAndSetState(O2mClientState.FINALIZING, O2mClientState.FAILED);
        } else {
            comareAndSetState(O2mClientState.FINALIZING, O2mClientState.CLOSED);
        }
    }

    @Override
    public O2mClientEvents getO2mClientEvents() {
        return o2mClientEvents;
    }

    @Override
    public O2mClientState getState() {
        return state.get();
    }

    @Override
    public void addEventListener(O2mClientEventListener listener) {
        Objects.requireNonNull(listener);

        o2mClientEvents.addEventListener(listener);
    }

    @Override
    public boolean removeEventListener(O2mClientEventListener listener) {
        Objects.requireNonNull(listener);

        return o2mClientEvents.removeEventListener(listener);
    }

    @Override
    public Future<ImmutableMessage> request(ImmutableMessage request) throws O2mServiceException {
        Objects.requireNonNull(request);

        long stamp = stateRWLock.readLock();
        try {
            if (!state.get().equals(O2mClientState.ACTIVE)) {
                throw new O2mServiceException(
                        "Client's state expected: " + O2mClientState.ACTIVE + " actual: " + state);
            }

            return requestPublisher.publishUserRequest(request).thenApply(message -> {
                return O2mMessages.Fields.Payload.get(message);
            });
        } finally {
            stateRWLock.unlockRead(stamp);
        }
    }

    @Override
    public O2mClientSubscription subscribe(String channelCode, O2mClientSubscriptionMode mode,
            O2mClientSubscriptionFilter filter, O2mClientSubscriptionCallback callback)
            throws O2mServiceException, UnsupportedOperationException {
        Objects.requireNonNull(channelCode);
        Objects.requireNonNull(mode);
        Objects.requireNonNull(filter);
        Objects.requireNonNull(callback);

        return checkStateAndSubscribe(channelCode, mode, filter, callback);
    }

    @Override
    public O2mClientSubscription subscribe(String channelCode, O2mClientSubscriptionMode mode,
            O2mClientSubscriptionCallback callback) throws O2mServiceException {
        Objects.requireNonNull(channelCode);
        Objects.requireNonNull(mode);
        Objects.requireNonNull(callback);

        return checkStateAndSubscribe(channelCode, mode, null, callback);
    }

    private O2mSubscriptionImpl checkStateAndSubscribe(String channelCode,
            O2mClientSubscriptionMode mode, @Nullable O2mClientSubscriptionFilter filter,
            O2mClientSubscriptionCallback callback) throws O2mServiceException {

        long stamp = stateRWLock.readLock();
        try {
            if (state.get() != O2mClientState.ACTIVE) {
                throw new O2mServiceException(
                        "Client's state expected: " + O2mClientState.ACTIVE + " actual: " + state);
            }

            if (mode == O2mClientSubscriptionMode.SNAPSHOT) {
                return doSubscribe(channelCode, mode, filter, callback);
            }

            try {
                final AtomicBoolean computedValue = new AtomicBoolean();
                O2mSubscriptionImpl result = liveSubscriptionByChannelCode
                        .computeIfAbsent(channelCode, code -> {
                            try {
                                computedValue.set(true);

                                return doSubscribe(channelCode, mode, filter, callback);
                            } catch (O2mServiceException e) {
                                throw new RuntimeException(e);
                            }
                        });

                if (!computedValue.get()) {
                    throw new O2mServiceException("Only one live subscription allowed.");
                }

                return result;
            } catch (RuntimeException e) {
                if (e.getCause() != null && e.getCause() instanceof O2mServiceException) {
                    throw (O2mServiceException) e.getCause();
                } else {
                    throw e;
                }
            }
        } finally {
            stateRWLock.unlockRead(stamp);
        }
    }

    private O2mSubscriptionImpl doSubscribe(String channelCode, O2mClientSubscriptionMode mode,
            @Nullable O2mClientSubscriptionFilter filter, O2mClientSubscriptionCallback callback)
            throws O2mServiceException {
        Objects.requireNonNull(channelCode);
        Objects.requireNonNull(mode);
        Objects.requireNonNull(callback);

        try {
            TransportTopic publishTopic = publishTopics.computeIfAbsent(channelCode, sessionId -> {
                String subject = publishSubjectProducer.apply(sessionId);
                try {
                    return transport.createTopic(subject, ProducerMode.NON_PERSISTENT,
                            ConsumerMode.NO_ACK);
                } catch (UnsupportedOperationException | TransportException e) {
                    throw new RuntimeException(e);
                }
            });

            TransportSubscriberSettings systemSettings = TransportSubscriberSettings.create();
            TransportSubscription publishSubscription = transport.subscribe(publishTopic,
                    systemSettings, (message) -> {
                        this.onPublishMessageReceived(channelCode, message);
                    });

            String subscriptionId = generateSubscriptionIdForChannelCode(channelCode);

            CompletableFuture<Message> future = requestPublisher.publishSubscribe(subscriptionId,
                    channelCode, mode, filter);

            O2mSubscriptionImpl subscription = new O2mSubscriptionImpl(subscriptionId, future,
                    publishSubscription, callback);
            allSubscriptionById.put(subscriptionId, subscription);

            return subscription;
        } catch (TransportException e) {
            throw new O2mServiceException(e);
        } catch (RuntimeException e) {
            if (e.getCause() != null && e.getCause() instanceof TransportException) {
                throw new O2mServiceException(e.getCause());
            } else {
                throw e;
            }
        }
    }

    /**
     * This is called from constructor. And all fields have been initialized.
     * 
     * @param config
     * @return <code>true</code> if connected.
     * 
     * @throws TransportException
     * @throws O2mServiceException
     * @throws InterruptedException
     */
    private boolean tryConnecting(O2mClientConfiguration config)
            throws TransportException, O2mServiceException, InterruptedException {
        Duration connectRetryInternal = config.getConnectRetryInternal();
        int connectMaxRetries = config.getConnectMaxRetries();

        int retries = 0;
        while (state.get() == O2mClientState.CONNECTING) {
            retries += 1;
            if (retries >= connectMaxRetries) {
                return false;
            }

            Future<Message> future = requestPublisher.publishClientConnect(config);

            try {
                Message reply = future.get(connectRetryInternal.toMillis(), TimeUnit.MILLISECONDS);

                int errorCode = O2mMessages.Fields.ErrorCode.tryGet(reply, O2mMessages.Consts.E_OK);
                if (errorCode == O2mMessages.Consts.E_OK) {
                    int heartbeatInterval = O2mMessages.Fields.ServerHeartbeatInterval.get(reply);
                    String serverSessionId = O2mMessages.Fields.ServerSessionId.get(reply);

                    this.serverHeartbeatInterval.set(Duration.ofMillis(heartbeatInterval));
                    this.serverSessionId.set(serverSessionId);

                    break;
                } else {
                    String errorText = O2mMessages.Fields.ErrorText.tryGet(reply).orElse(null);

                    o2mClientEvents.onConnectRejected(errorCode, errorText);
                    return false;
                }
            } catch (TimeoutException ex) {
                o2mClientEvents.onConnectTimeOut(retries);
            } catch (ExecutionException e) {
                o2mClientEvents.onConnectFailed(e);
                return false;
            }
        }

        return true;
    }

    private void onSystemMessage(Message message) {
        String msgType = O2mMessages.Fields.MessageType.get(message);
        ClientMessageHandler handler = clientMessageHandlers.get(msgType);
        if (handler == null) {
            o2mClientEvents.onUnknownMessageType(msgType);
            return;
        }

        try {
            handler.onMessage(O2mChannelType.SYSTEM, null, message);
        } catch (Exception e) {
            o2mClientEvents.onSystemMessageHandlerFailed(message, e);
        }
    }

    private void onPublishMessageReceived(String channelCode, Message message) {
        String msgType = O2mMessages.Fields.MessageType.get(message);
        ClientMessageHandler handler = clientMessageHandlers.get(msgType);
        if (handler == null) {
            o2mClientEvents.onUnknownMessageType(msgType);
            return;
        }

        try {
            handler.onMessage(O2mChannelType.PUBLISH, channelCode, message);
        } catch (Exception e) {
            o2mClientEvents.onPublishMessageHandlerFailed(channelCode, message, e);
        }
    }

    private void onSessionMessage(Message message) {
        String msgType = O2mMessages.Fields.MessageType.get(message);
        ClientMessageHandler handler = clientMessageHandlers.get(msgType);
        if (handler == null) {
            o2mClientEvents.onUnknownMessageType(msgType);
            return;
        }

        try {
            handler.onMessage(O2mChannelType.SESSION, null, message);
        } catch (Exception e) {
            o2mClientEvents.onSessionMessageHandlerFailed(message, e);
        }
    }

    @Override
    public CompletableFuture<Message> getAndRemovePendingRequest(long requestId) {
        return pendingRequests.remove(requestId);
    }

    @Override
    public O2mSubscriptionImpl getSubscriptionById(String subscriptionId) {
        return allSubscriptionById.get(subscriptionId);
    }

    @Override
    public O2mSubscriptionImpl getSubscriptionByChannelCode(String channelCode) {
        return liveSubscriptionByChannelCode.get(channelCode);
    }

    private boolean comareAndSetState(O2mClientState oldState, O2mClientState newState)
            throws InterruptedException {
        long stamp = stateRWLock.writeLock();
        try {
            if (!state.compareAndSet(oldState, newState)) {
                return false;
            }

            this.o2mClientEvents.onStateChanged(oldState, newState);

            return true;
        } finally {
            stateRWLock.unlockWrite(stamp);
        }
    }

    /**
     * Generated subscription id is unique per session.
     * 
     * @param channelCode
     *            channel code.
     * @return unique subscription id per session.
     */
    private String generateSubscriptionIdForChannelCode(String channelCode) {
        AtomicLong nextSubscriptionId = nextSubscriptionIdForChannelCode
                .computeIfAbsent(channelCode, code -> new AtomicLong(1));

        return channelCode + "-" + nextSubscriptionId.getAndIncrement();
    }

    /**
     * Every subscription has its own thread, may not be a good design. Aggregated them into a
     * single thread could be better.
     * 
     * @author Dop Sun
     * @since 1.0.0
     */
    final class O2mSubscriptionImpl implements O2mClientSubscription {
        private final String subscriptionId;
        private final CompletableFuture<Message> replyFuture;
        private final TransportSubscription transportSubscription;

        private final CompletableFuture<Boolean> snapshotReceived;

        /**
         * Holds pending messages before snapshot completed.
         */
        private final TransferQueue<Message> updateMessages = new LinkedTransferQueue<>();

        private final TransferQueue<ImmutableMessage> snapshotMessages = new LinkedTransferQueue<>();
        private volatile boolean snapshotCleared = false;

        private volatile long nextUpdateMessageId = -1;

        private final Service subscriptionDispatchService;

        /**
         * @param subscriptionId
         * @param replyFuture
         * @param transportSubscription
         * @param callback
         */
        public O2mSubscriptionImpl(String subscriptionId, CompletableFuture<Message> replyFuture,
                TransportSubscription transportSubscription,
                O2mClientSubscriptionCallback callback) {
            Objects.requireNonNull(subscriptionId);
            Objects.requireNonNull(replyFuture);
            Objects.requireNonNull(transportSubscription);
            Objects.requireNonNull(callback);

            this.subscriptionId = subscriptionId;
            this.replyFuture = replyFuture;
            this.transportSubscription = transportSubscription;

            this.snapshotReceived = new CompletableFuture<>();

            this.subscriptionDispatchService = new AbstractExecutionThreadService() {
                @Override
                protected void run() throws Exception {
                    while (isRunning()) {
                        if (snapshotReceived.isDone()) {
                            if (!snapshotCleared) {
                                ImmutableMessage message = snapshotMessages.poll();
                                while (message != null) {
                                    callback.accept(true, message);

                                    message = snapshotMessages.poll();
                                }

                                snapshotCleared = true;
                            }

                            Message message = updateMessages.poll(100, TimeUnit.MILLISECONDS);
                            if (message != null) {
                                if (O2mMessages.Fields.SeqNum.get(message) >= nextUpdateMessageId) {
                                    callback.accept(false, O2mMessages.Fields.Payload.get(message));
                                }
                            }
                        } else {
                            // FIXME: if replied received, but snapshot is empty, but in between,
                            // there could be one idle wait for snapshot messages.
                            //
                            // One possible is: set the snapshotReceived flag before set reply
                            // received. But for that, it will waitForSnapshot return before
                            // waitForReply.
                            //
                            // Another option is: has another flag to indicating whether snapshot
                            // available. And this flag is set before reply received.
                            ImmutableMessage message = snapshotMessages.poll(100,
                                    TimeUnit.MILLISECONDS);
                            if (message != null) {
                                callback.accept(true, message);
                            }
                        }
                    }
                }
            };

            subscriptionDispatchService.startAsync().awaitRunning();
        }

        void onPublishMessageReceived(Message message) {
            if (!updateMessages.tryTransfer(message)) {
                updateMessages.add(message);
            }
        }

        void onReplyReceived(Message msgReply) {
            replyFuture.complete(msgReply);

            nextUpdateMessageId = O2mMessages.Fields.NextChannelSeqNum.get(msgReply);

            boolean snapshotExists = O2mMessages.Fields.SnapshotExists.tryGet(msgReply, false);
            if (!snapshotExists) {
                snapshotReceived.complete(true);
            }
        }

        void onSnapshotReceived(Message message) {
            ChannelSnapshotReader reader = O2mMessages.readChannelSnapshot(message);
            ImmutableMessage msgPayload = reader.getPayload();

            if (!snapshotMessages.tryTransfer(msgPayload)) {
                snapshotMessages.add(msgPayload);
            }

            boolean isLast = reader.tryGetSnapshotIsLast(false);
            if (isLast) {
                snapshotReceived.complete(true);
            }
        }

        @Override
        public void waitForReply(long timeout, TimeUnit unit)
                throws InterruptedException, TimeoutException, ExecutionException {
            replyFuture.get(timeout, unit);
        }

        @Override
        public void waitForSnapshotCompleted(long timeout, TimeUnit unit)
                throws TimeoutException, InterruptedException, ExecutionException {
            snapshotReceived.get(timeout, unit);
        }

        @Override
        public void close() throws Exception {
            subscriptionDispatchService.stopAsync().awaitTerminated();

            O2mClientImpl.this.allSubscriptionById.remove(subscriptionId);

            transportSubscription.close();

            if (!replyFuture.isDone()) {
                replyFuture.cancel(true);
            }
        }
    }
}
